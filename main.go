// Generated by Gemini 2.5 Pro

package main

import (
	"archive/zip"
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
)

const (
	VERSION   = "0.1.0"
	RUN_SH    = "run.sh"
	BOOTSTRAP = "bootstrap"
)

// zipDirectory compresses the entire contents of the sourceDir directory
// into a zip file named targetZipFile.
//
// If files named "run.sh" or "bootstrap" are found, they are given
// Unix executable permissions (0755).
// The "run.sh" file will also have its line endings converted to LF.
func zipDirectory(sourceDir, targetZipFile string) error {
	// 1. Create the target zip file. It will overwrite if it already exists.
	zipFile, err := os.Create(targetZipFile)
	if err != nil {
		return err
	}
	defer zipFile.Close()

	// 2. Initialize a new zip.Writer to write to the zip file.
	zipWriter := zip.NewWriter(zipFile)
	defer zipWriter.Close()

	// Use the clean path of the source directory as the base.
	baseDir := filepath.Clean(sourceDir)

	// 3. Walk through all the files and directories recursively.
	return filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Don't include the source directory itself in the zip archive.
		if path == baseDir {
			return nil
		}

		// 4. Create a zip FileHeader from the FileInfo.
		header, err := zip.FileInfoHeader(info)
		if err != nil {
			return err
		}

		// 5. Set the file name in the header to be a relative path from the source directory.
		relPath, err := filepath.Rel(baseDir, path)
		if err != nil {
			return err
		}
		// Use forward slashes for path separators for cross-platform compatibility.
		header.Name = filepath.ToSlash(relPath)

		if info.IsDir() {
			// If it's a directory, add a trailing slash to the name.
			header.Name += "/"
		} else {
			// If it's a file, set the compression method (Deflate is common).
			header.Method = zip.Deflate

			// 6. Grant executable permissions to "run.sh" and "bootstrap".
			if info.Name() == RUN_SH || info.Name() == BOOTSTRAP {
				// Set the file mode to 0755 (rwxr-xr-x).
				header.SetMode(0755)
			}
		}

		// 7. Write the header to the zip writer.
		writer, err := zipWriter.CreateHeader(header)
		if err != nil {
			return err
		}

		// 8. If it's not a directory, write the file's content.
		if !info.IsDir() {
			file, err := os.Open(path)
			if err != nil {
				return err
			}
			defer file.Close()

			// If the file is "run.sh", convert its line endings to LF before writing.
			if info.Name() == RUN_SH {
				// Read the entire file content into memory.
				content, err := io.ReadAll(file)
				if err != nil {
					return err
				}

				// Replace CRLF (\r\n) with LF (\n).
				crlf := []byte{'\r', '\n'}
				lf := []byte{'\n'}
				content = bytes.ReplaceAll(content, crlf, lf)

				// Write the modified content to the zip archive.
				_, err = writer.Write(content)
				if err != nil {
					return err
				}
			} else {
				// For all other files, copy the content directly.
				_, err = io.Copy(writer, file)
				if err != nil {
					return err
				}
			}
		}

		return nil
	})
}

func main() {
	// get cmd arguments
	args := os.Args
	if len(args) < 3 {
		fmt.Println("Usage: lzpb <source_dir> <target_zip>")
		return
	}
	sourceDir := args[1]
	targetZip := args[2]
	zipDirectory(sourceDir, targetZip)
}
